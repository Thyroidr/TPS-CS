{"meta":{"title":"Telopea CS","subtitle":"CS Course for Telopea Park School, 2019","description":null,"author":"Ryan Wang","url":"https://thyroidr.github.io/TPS-CS","root":"/TPS-CS/"},"pages":[{"title":"about","date":"2019-03-25T08:25:20.000Z","updated":"2019-03-25T08:25:31.004Z","comments":true,"path":"about/index.html","permalink":"https://thyroidr.github.io/TPS-CS/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-11T03:31:26.000Z","updated":"2019-03-11T03:32:48.461Z","comments":true,"path":"categories/index.html","permalink":"https://thyroidr.github.io/TPS-CS/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Binary Search and Algorithmic Analysis","slug":"Binary-Search-and-Algorithmic-Analysis","date":"2019-03-20T03:13:02.000Z","updated":"2019-03-25T10:11:50.882Z","comments":true,"path":"Binary-Search-and-Algorithmic-Analysis/","link":"","permalink":"https://thyroidr.github.io/TPS-CS/Binary-Search-and-Algorithmic-Analysis/","excerpt":"Consider a list of numbers in increasing order (that is, every number except the first is bigger than the previous number), e.g. 11 7 8 12 14 15 22 23 26 29 Suppse we want to develop an efficient method (algorithm) to find the smallest number in the list, that is larger than $x$. The simple method is just to iterate over the list, maintaining the smallest number larger than x that we have iterated so far and updating it at every step of iteration. This has a time complexity linear to the size of the list (which we will denote using $n$), we describe this using the Big-O notation $O(n)$. The Big-O notation roughly describes the number of computations needed to run an algorithm, in relation to some variables (in the above case $n$). Let the actual number of computations needed be function $a$, then contents of $O(\\ldots)$ is a function $f$, such that for some $[k, \\infty]$ values of the variables, $\\exists l, h: lf \\le a \\le hf$. You can simply understand this as $f$ is a basic expression that best approximates $a$. The major question in informatics is how can we minimise the time complexity to solve certain problems. In this case, $O(n)$ is considered a poor time complexity. A time complexity of $O(\\log_2 n)$ can be achieved using a technique of binary search ($\\log_2 n$ grows much slower compared to $n$, when $n = 10^6$, $\\log_2 n \\le 20$).","text":"Consider a list of numbers in increasing order (that is, every number except the first is bigger than the previous number), e.g. 11 7 8 12 14 15 22 23 26 29 Suppse we want to develop an efficient method (algorithm) to find the smallest number in the list, that is larger than $x$. The simple method is just to iterate over the list, maintaining the smallest number larger than x that we have iterated so far and updating it at every step of iteration. This has a time complexity linear to the size of the list (which we will denote using $n$), we describe this using the Big-O notation $O(n)$. The Big-O notation roughly describes the number of computations needed to run an algorithm, in relation to some variables (in the above case $n$). Let the actual number of computations needed be function $a$, then contents of $O(\\ldots)$ is a function $f$, such that for some $[k, \\infty]$ values of the variables, $\\exists l, h: lf \\le a \\le hf$. You can simply understand this as $f$ is a basic expression that best approximates $a$. The major question in informatics is how can we minimise the time complexity to solve certain problems. In this case, $O(n)$ is considered a poor time complexity. A time complexity of $O(\\log_2 n)$ can be achieved using a technique of binary search ($\\log_2 n$ grows much slower compared to $n$, when $n = 10^6$, $\\log_2 n \\le 20$). Binary SearchThe technique uses the fact the numbers are sorted (the list is monotonic). In the following precedure, we denote the range the answer could be in as $[l, r]$, and the $i$-th element of the list as $A_i$. Procedure Let us denote the number of numbers in the list as $n$. We will also set $l$ to $1$ and $r$ to $n$. If $l = r$, then we have found the answer, it is the $l$-th element, terminate. Set $m$ (the middle element of $[l, r]$) to the floor of $\\frac{l+r}{2}$. If $A_m \\le x$ , set $l$ to $m+1$, else set $r$ to $m$, go to step 2. Code12345678int l = 1, r = n;while(l != r)&#123; int m = (l + r) / 2; if(A[m] &lt;= x) l = m + 1; else r = m;&#125; Time ComplexityNotice that $\\log_2 k$ essentially means how many times do we need to divide $k$ by $2$ to get something smaller than 1 (only for positive $k$’s). Discuss why $O(\\log_2 n)$ might be the time complexity for binary search. ExerciseGoogle Kick Start 2019 Practice Round: https://codingcompetitions.withgoogle.com/kickstart/round/0000000000051060/00000000000588f4 This problem might take you a long time thinking or googling about binary searchFARIO 2009: http://orac.amt.edu.au/cgi-bin/train/problem.pl?problemid=378 Ctrl-A for hint:Consider binary searching the possible answers and then testing if they are possible","categories":[{"name":"intro","slug":"intro","permalink":"https://thyroidr.github.io/TPS-CS/categories/intro/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://thyroidr.github.io/TPS-CS/tags/algo/"}],"author":"Ryan Wang"},{"title":"Basic C++: Conditional Statements and Loops","slug":"Basic-C++/Basic-C-Conditional-Statements-and-Loops","date":"2019-03-11T03:28:58.000Z","updated":"2019-03-25T10:12:02.350Z","comments":true,"path":"Basic-C++/Basic-C-Conditional-Statements-and-Loops/","link":"","permalink":"https://thyroidr.github.io/TPS-CS/Basic-C++/Basic-C-Conditional-Statements-and-Loops/","excerpt":"Boolean OperatorsIn addition to the arithmetic operators, there are also the boolean (logic) operators in C++. These are the operators that return a true value or a false value. true and false values can be replaced with 1 and 0 respectively, although really, in C++, 0 is false, and everything else is true. The operators below can be used to compare regular variables (so long as they have the operators defined, you don’t need to worry abot this). Operator Function Example == returns true if the values of the operands are equal a == b &gt;= returns true if the value of the left operand is greater than or equal to the right operator a &gt;= b &lt;= returns true if the value of the left operand is lower than or equal to the right operator a &lt;= b &gt; returns true if the value of the left operand is greater than the right operator a &gt; b &lt; returns true if the value of the left operand is lower than the right operator a &lt; b The following operators are used for logical operations, in general, the operands for these should be boolean variables or expressions. Operator Function Example ! not, changes false to true and true to false !a &amp;&amp; and, return true if and only if both operands are true a == b &amp;&amp; c &gt; a &#124;&#124; or, returns true if and only if at least one of the operands is true a == b &#124;&#124; a &gt; b","text":"Boolean OperatorsIn addition to the arithmetic operators, there are also the boolean (logic) operators in C++. These are the operators that return a true value or a false value. true and false values can be replaced with 1 and 0 respectively, although really, in C++, 0 is false, and everything else is true. The operators below can be used to compare regular variables (so long as they have the operators defined, you don’t need to worry abot this). Operator Function Example == returns true if the values of the operands are equal a == b &gt;= returns true if the value of the left operand is greater than or equal to the right operator a &gt;= b &lt;= returns true if the value of the left operand is lower than or equal to the right operator a &lt;= b &gt; returns true if the value of the left operand is greater than the right operator a &gt; b &lt; returns true if the value of the left operand is lower than the right operator a &lt; b The following operators are used for logical operations, in general, the operands for these should be boolean variables or expressions. Operator Function Example ! not, changes false to true and true to false !a &amp;&amp; and, return true if and only if both operands are true a == b &amp;&amp; c &gt; a &#124;&#124; or, returns true if and only if at least one of the operands is true a == b &#124;&#124; a &gt; b 1234567891011121314151617181920212223242526272829303132333435/*structure of if...else statements:if(boolean statement)&#123; what to do if statement is true&#125; else &#123; what to do if statement is false&#125;*/#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b; cin&gt;&gt;a&gt;&gt;b; if(a == b)&#123; cout&lt;&lt;\"EQUAL\"&lt;&lt;endl; &#125; bool equal; equal = (a == b); // boolean variables can be assigned // boolean statements if(!equal)&#123; cout&lt;&lt;\"NOT EQUAL\"&lt;&lt;endl; &#125; if(a + b == 10)&#123; // arithmetic expressions go before // boolean statements cout&lt;&lt;\"SUM TO 10\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"DO NOT SUM TO 10\"&lt;&lt;endl; &#125; return 0;&#125; Loops“I go to school until the end of the term” is a loop statement. In this sentence, we have a condition “until the end of the term” and an action “I go to school”. While “the time is not the end of the term”, “I go to school”. The “for” Statement1234for(Line_A; statement; Line_B)&#123; ......; ......;&#125; Line_A is executed in the beginning of the loop; Line_B is executed at the end of every cycle. An example for statement may be, 1234for(int i = 1; i &lt;= 5; i++)&#123; s[i] = s[i] + 1; book[s[i]] = true;&#125; The above code would run 5 times, adding 1 to s[1...5], and setting book[s[1....5]] to true. The “while” StatementBelow is a template of the while statement:123while(statement)&#123; ......;&#125; While the statement is true, the lines within the large brackets are executed. An example while statement is below,1234while(l &lt; r)&#123; if(s[l] &gt; s[r]) r--; else l++;&#125; “Continue” &amp; “Break” KeywordThere are two keywords that may be used in loops to essentially jump around in the loop, keyword function continue skip the remaining of this cycle (if used in a for loop, the end-cycle line still executes) break exit the loop Below is an example12345for(int i = 1; i &lt;= 5; i++)&#123; if(i == 3) continue; if(i == 5) break; cout&lt;&lt;i&lt;&lt;endl;&#125; The output would be:124 ExerciseSolve A Mindbending Scenario and The Trenmendous Tak-Tak Tree on Orac.","categories":[{"name":"Basic C++","slug":"Basic-C","permalink":"https://thyroidr.github.io/TPS-CS/categories/Basic-C/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://thyroidr.github.io/TPS-CS/tags/c/"}],"author":"Ryan Wang"},{"title":"Basic C++: IO & Variables & Simple Arithmetics","slug":"Basic-C++/Basic-C-IO-Variables-Simple-Arithmetics","date":"2019-03-11T03:28:41.000Z","updated":"2019-03-25T10:12:33.788Z","comments":true,"path":"Basic-C++/Basic-C-IO-Variables-Simple-Arithmetics/","link":"","permalink":"https://thyroidr.github.io/TPS-CS/Basic-C++/Basic-C-IO-Variables-Simple-Arithmetics/","excerpt":"https://www.onlinegdb.com/myfilesSee:IO: https://thyroidr.github.io/Basic-C++/input-output/ then students do “Hello World!”Variables: https://thyroidr.github.io/Basic-C++/variables/ then students declare and print variable. Simple ArithmeticsUnitary Operators Operators Operation Placement Example ++ Add 1 to the operand In front of or after the operand ++a or a++ – Subtract 1 from the operand In front of or after the operand --a or a--","text":"https://www.onlinegdb.com/myfilesSee:IO: https://thyroidr.github.io/Basic-C++/input-output/ then students do “Hello World!”Variables: https://thyroidr.github.io/Basic-C++/variables/ then students declare and print variable. Simple ArithmeticsUnitary Operators Operators Operation Placement Example ++ Add 1 to the operand In front of or after the operand ++a or a++ – Subtract 1 from the operand In front of or after the operand --a or a-- Binary Operators Operators Operation Placement Example = Assigns the value of the back operand to the front operand Between operands a = b + Returns the sum of two operands Between operands a + b - Returns the difference between the two operands Between operands a - b * Returns the product of the two operands Between operands a * b / Returns the quotient of the two operands (rounded down if needed) Between operands a / b % Returns the remainder of the two operands Between operands a % b Having a = sign after a binary operator other than = is equivalent to operate then assign, e.g.a += b is equivalent to a = a + b. Students then solve Addition and Sitting or Standing? on Orac if time permits.","categories":[{"name":"Basic C++","slug":"Basic-C","permalink":"https://thyroidr.github.io/TPS-CS/categories/Basic-C/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://thyroidr.github.io/TPS-CS/tags/c/"}],"author":"Ryan Wang"},{"title":"Course Outline","slug":"Course-Outline","date":"2019-03-11T03:28:07.000Z","updated":"2019-03-11T03:40:27.829Z","comments":true,"path":"Course-Outline/","link":"","permalink":"https://thyroidr.github.io/TPS-CS/Course-Outline/","excerpt":"","text":"“Computer science is no more about computers than astronomy is about telescopes” - Edsger Dijkstra Course delivered by Ryan Wang (current year 11 student at Bundah). GoalThe course is aimed to improve students’ problem solving abilities and computational thinking. Skills developed are applicable in other STEM subjects. Contents covered are also mostly part of Undergraduate CS courses. This course targets and should be of interest to anyone interested in CS. Examples of contents that will be covered down the track include: Dijkstra’s shortest algorithm, Dynamic Programming, Monotone data structures, Algorithmic analysis. MethodThe the first few lessons students will unfortunately have to use online IDEs (https://www.onlinegdb.com/myfiles is acceptable). Compilers and editors will hopefully be installed on school computers (or student computers if they wish to bring them) later on. The course will be taught using C++ (don’t stress, we will only need the very basics of C++). The focus is not on the programming language, rather, it is on the algorithms that are applicable to all programming languages. Each lesson will run for 60-90 minutes. Each lesson will start off with a lecture for 20 to 30 minutes, during which theoretical contents will be covered and students do not need their computers for programming (please use pen &amp; paper to take notes). The lesson will then move to lab time, during which students implement and (hopefully) extend beyond what the lecture has covered. Lab and lecture time will be mixed in the first few lessons. Students will need to solve problems on the training site by Australian Informatics Olympiad Committee at http://orac.amt.edu.au/cgi-bin/train/hub.pl. Help can be found at my blog for computer science, https://thyroidr.github.io under the Basic-C++ category. In addition, all lecture notes will be available at https://thyroidr.github.io/TLPS-CS. Plan Week Content Other 3 Basic C++: IO &amp; Variables &amp; Simple Arithmetics Solve Addition and Sitting or Standing? 6 Basic C++: Conditional statements &amp; loops 7 Basic C++: Functions 8 Binary search and simple algorithmic analysis Actual computer science 10 Solving trivial problems May not take place","categories":[],"tags":[],"author":"Ryan Wang"}]}